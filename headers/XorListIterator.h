#pragma once #include <iterator>  template<class list, class T> class iteratorBase : public std::iterator<std::random_access_iterator_tag, T> { public:  	iteratorBase(list *d, size_t index) : index(index), list_ptr(d) { 	} 	iteratorBase() { 		list_ptr = NULL; 		index = 0; 	}  	iteratorBase(const iteratorBase &other) { 		index = other.index; 		list_ptr = other.list_ptr; 	}  	T* operator->() { 		return &((*list_ptr)[index]); 	}  	T& operator*() { 		return (*list_ptr)[index]; 	}  	iteratorBase& operator++() { 		index++; 		return (*this); 	}  	iteratorBase& operator++(int) { 		iteratorBase bi(*this); 		index++; 		return bi; 	}  	iteratorBase& operator--() { 		index--; 		return (*this); 	}  	iteratorBase& operator--(int) { 		iteratorBase bi(*this); 		index--; 		return bi; 	}  	iteratorBase& operator+=(size_t n) { 		index += n; 		return (*this); 	}  	iteratorBase& operator-=(size_t n) { 		index -= n; 		return (*this); 	}   	iteratorBase operator+(const size_t n) const { 		iteratorBase temp(*this); 		temp += n; 		return temp; 	}  	iteratorBase operator-(const size_t n) const { 		iteratorBase temp(*this); 		temp -= n; 		return temp; 	}  	int operator-(const iteratorBase &other) const { 		return index - other.index; 	}  	int operator+(const iteratorBase &other) const { 		return index + other.index; 	}  	bool operator==(const iteratorBase &other) const { 		return (index == other.index && list_ptr == other.list_ptr); 	}  	bool operator<(const iteratorBase &other) const { 		return (index < other.index); 	}  	bool operator!=(const iteratorBase &other) const { 		return !((*this) == other); 	}  	bool operator<=(const iteratorBase &other) const { 		return (index <= other.index); 	}  private: 	T value; 	size_t index; 	list* list_ptr; }; 